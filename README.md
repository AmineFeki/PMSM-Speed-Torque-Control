# PMSM-Speed-Torque-Control
This project is within an electro-mobility internship.
It includes a full documentation about the theoretical study and a simple demo of the Speed and Torque control of the PMSM.

Nowaday, electro-mobility presents high technology in the field of mobility.
Mastering Permanent Magnet Synchronous Motors is one of the most powerful keys that helps integrating the field of Ellectric Vehicles and Electro-mobility.

I have worked on this topic to enhance my skills not only in embedded systems engineering, but also in motor control.

This project is based on the STMicroelectronics Tool: MotorControl Workbench.
I have used the EVSPIN32G4 board of STMicroelectronics and an SM-PMSM equipped with integrated Hall sensors.

Let's start!

# I. Theoretical study: Physical & Mathematical study:
Differently to the BLDC and the trapezoidal command based on 6-Step algorithm, the PMSM is here with a sinusoidal command thanks to Field Oriented Control (FOC) algorithm.
The FOC has the advantage of maximizing torque and eliminating torque ripples.
![image](https://user-images.githubusercontent.com/53936812/183282827-5ae5f6c4-1780-470a-8d5d-6d321f1bc402.png)

The current vector I has two 2D-components: Iq and Id.
Obtaining a maximized value of the torque returns to obtaining a maximized value of the current which is obtained by making Id = 0 and Iq maximized.
The sinusoidal command allows us having this result. Figure 3 shows the currents Ia, Ib and Ic in the 3 PMSM phases and the resultant current vector with its two components Iq and Id.

![image](https://user-images.githubusercontent.com/53936812/183282862-df35f54f-47df-4695-b5b5-7892525141fa.png)


It is necessary to implement PI controllers to adjust the values of Ia, Ib and Ic.
To do so, we need to implement the Clarke-Park transformation that simplifies the process.
(ğ›¼,ğ›½) an immobile base on the PMSM stator.
(ğ‘‘,ğ‘) an immobile base on the PMSM rotator.
Through a simple trigonometric development, we can conclude that:

![image](https://user-images.githubusercontent.com/53936812/183282876-65167933-3022-4786-a5e3-19b34f6cba2a.png)

Here is the block diagram that resumes the FOC algorithm:

![image](https://user-images.githubusercontent.com/53936812/183282909-fb774f00-61e9-4c57-aef8-3c13bd8c3f47.png)

# II. Hadrware:
## a. [DB42M03](https://en.nanotec.com/fileadmin/files/Datenblaetter/BLDC/DB42/DB42M03.pdf) PMSM:
It represents an SM-PMSM.
Characteristics:

â€¢ Pole pairs number: 4

â€¢ Rs = 0.4 Î©

â€¢ Ls = 0.6 mH 

â€¢ J = 4.8 E-6 kg.m2

## b. [EVSPIN32G4](https://www.st.com/resource/en/user_manual/um2850-getting-started-with-the-evspin32g4-evspin32g4nh-stmicroelectronics.pdf):

# III. Software tool: ST MC Workbench

![image](https://user-images.githubusercontent.com/53936812/183283186-4e0b2a7b-b1bb-4c9b-b6d3-5e0eaf84926c.png)

It is important to mention that it is important to enter carefully the parameters. The electrical and
mechanical parameters may be useful in calculation the PID constants.

After entering all the required parameters, we generate code, and explore it with STM32CubeIDE.

# IV: Speed control:

The goal here is set a setpoint of the speed called Reference Speed (RefSpeed), and we use PID
controllers to obtain the result.
We use several functions of the library generated by the ST Workbench.

We use the function ```MC_StartMotor1()``` to start the motor, then the ```MC_ProgramSpeedRampMotor1(500, 500)``` function to set the desired speed.

â€¢ The first parameter represents the desired speed in SPEED_UNIT (corresponds to 6 RPM) â” the
parameter 500 corresponds to 3000 RPM.

â€¢ The second parameter presents the ramp time in milliseconds. â” the parameter 500 corresponds
to 500 ms.

Before building the project, we would like to plot the reference speed and the real speed. So, we
used the functions below:

```M_RefSpeed = MC_GetMecSpeedReferenceMotor1_F();```
```M_Speed = MC_GetAverageMecSpeedMotor1_F();```

We build the project and run it.

Using the STM32CubeMonitor, we plot the M_RefSpeed and the M_Speed variables.

![image](https://user-images.githubusercontent.com/53936812/183283465-5052d065-ca3e-44ea-a1b2-7f799589edd7.png)


We received the error FAULT_OVER in the pMCI[0]->State.

### Interpretation:
The shape of the plotted signal presents a non-stability.

â” Our system is not stable, and we need to adjust the Kp and Ki constants of the speed PID
controller. For that, we use:

```PID_SetKP(&PIDSpeedHandle_M1, 100);```
```PID_SetKI(&PIDSpeedHandle_M1, 20);```

â” Time to set the the regulator constants:

Here are the followed steps to obtain a good result:

1- Make Ki = 0.

2- Augment Kp, till we obtain the feedback follows 80% to 90% of the set point.

3- Augment Ki to reach the 100%.

PS: it is important to mention that Kp and Ki should not be oversized in order to not have a
destabilization.

After multiple tests, we set Kp = 100 and Ki = 20.

Finally, we obtained the result below:

![image](https://user-images.githubusercontent.com/53936812/183283509-25184976-aec6-4f79-a1e8-7a2fbfb8a001.png)

Here the speed follows the setpoint perfectly.

# V. Torque control:

Now, it is time to make the torque control.
As we know, ğ‘‡ğ‘œğ‘Ÿğ‘ğ‘¢ğ‘’ = ğ¾ğ‘¡ âˆ— ğ¼. â” Controlling the torque returns to controlling the current.
The bloc diagram becomes:

![image](https://user-images.githubusercontent.com/53936812/183283572-24417622-64ae-4f05-a7ea-c32ec2ffd8bc.png)

PS: Here comes an important remark. To have a normal performance, it is necessary to use a
resistive charge on the shaft of the motor. In this context, in the ST firmware, a threshold is set: when the rotor
speed reaches this threshold, the motor is disables.

We all know that ğ‘‡ğ‘œğ‘Ÿğ‘ğ‘¢ğ‘’ = ğ½ âˆ— ğœ”Ì‡ ;
ğ½: ğ¼ğ‘›ğ‘’ğ‘Ÿğ‘¡ğ‘–ğ‘ ğ‘šğ‘œğ‘šğ‘’ğ‘›ğ‘¡
ğœ”Ì‡ : ğ‘ğ‘›ğ‘”ğ‘¢ğ‘™ğ‘ğ‘Ÿ ğ‘ ğ‘ğ‘’ğ‘’ğ‘‘

If Torque and J are constants, the ğœ”Ì‡ is constant. â” ğœ” will tend to an infinite value which will make
it run in a speed superior that the synchronism speed and damage the motor.

Identically to the speed control workflow, we use the function ```MC_StartMotor1()``` to start the motor, then the
```MC_ProgramTorqueRampMotor1(400, 500)``` function to set the desired speed.

â€¢ The first parameter represents the desired Iq value in digit, which is calculated using the formula
below:
Current (digit) = [Current(Amp) * 65536 * Rshunt * Aop] / Vdd micro
Rshunt = 5mOhm; Aop (amplification gain) = 7.33; Vdd micro = 3v3;
â”  The paramet 400 corresponds to 0.55 A

â€¢ The second parameter presents the ramp time in milliseconds. â” the parameter 500 corresponds
to 500 ms.

Before building the project, we would like to plot the reference speed and the real speed. So, we
used the functions below:

```M_RefIq = MCI_GetIqdref_F(pMCI[0]).q;```

```M_RefId = MCI_GetIqdref_F(pMCI[0]).d;```

```M_Iq = MCI_GetIqd_F(pMCI[0]).q;```

```M_Id = MCI_GetIqd_F(pMCI[0]).d;```

After running the code and adjusting the regulator constants values, we obtain the result below:

![image](https://user-images.githubusercontent.com/53936812/183283728-c7184ed2-74de-4253-919d-567b0c2c07fc.png)

### Interpretation:
Iq follows the setpoint, which is equal to 0.55 A.

Id follows the setpoint, which is equal to 0 A.

## Other observations:

![image](https://user-images.githubusercontent.com/53936812/183283777-c8edffce-cba2-47ab-a569-16161e977933.png)


### Interpretation:
Depending on the resistive torque applied to the shaft of the motor, the velocity changes.
If the ğ‘‡ğ‘Ÿğ‘’ğ‘ ğ‘–ğ‘ ğ‘¡ğ‘–ğ‘£ğ‘’> ğ‘‡ğ‘”ğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘’ğ‘‘, then the motor stops (the rotor speed is equal to zero). It is no longer able to compensate the resistive torque.

# VI. Other remarks in relation with the ST workbench:
Each PID controller is handled by a structure called PID_Handle_t. In this structure, there default regulator constants called respectively hDefKpGain and hDefKiGain which will be used in case the hKpGain and hKiGain are equal to 0.0.
